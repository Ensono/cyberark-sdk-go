/*
CyberArkIAG

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 18a45ad8-77e8-4ecc-873e-787c6de10a60
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// BulkUploadOfAccountsApiService BulkUploadOfAccountsApi service
type BulkUploadOfAccountsApiService service

type ApiCreateBulkUploadofAccountsRequest struct {
	ctx _context.Context
	ApiService *BulkUploadOfAccountsApiService
	authorization *string
	contentType *string
	body *string
}

// Session Authorization Token
func (r ApiCreateBulkUploadofAccountsRequest) Authorization(authorization string) ApiCreateBulkUploadofAccountsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiCreateBulkUploadofAccountsRequest) ContentType(contentType string) ApiCreateBulkUploadofAccountsRequest {
	r.contentType = &contentType
	return r
}
// This method allows a developer to add multiple accounts to existing Safes. The response contains the ID of the bulk account upload that was performed.     **Note:** This option is only available if you have **Add accounts**, **Update account content**, and **Update account properties** authorization in at least one Safe.
func (r ApiCreateBulkUploadofAccountsRequest) Body(body string) ApiCreateBulkUploadofAccountsRequest {
	r.body = &body
	return r
}

func (r ApiCreateBulkUploadofAccountsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateBulkUploadofAccountsExecute(r)
}

/*
CreateBulkUploadofAccounts Create Bulk Upload of Accounts

This method allows a developer to add multiple accounts to existing Safes. The response contains the ID of the bulk account upload that was performed.
  	
**Note:** This option is only available if you have **Add accounts**, **Update account content**, and **Update account properties** authorization in at least one Safe.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBulkUploadofAccountsRequest
*/
func (a *BulkUploadOfAccountsApiService) CreateBulkUploadofAccounts(ctx _context.Context) ApiCreateBulkUploadofAccountsRequest {
	return ApiCreateBulkUploadofAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BulkUploadOfAccountsApiService) CreateBulkUploadofAccountsExecute(r ApiCreateBulkUploadofAccountsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadOfAccountsApiService.CreateBulkUploadofAccounts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/bulkactions/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllBulkAccountUploadsforUserRequest struct {
	ctx _context.Context
	ApiService *BulkUploadOfAccountsApiService
	filter *float32
	limit *float32
	authorization *string
	contentType *string
}

// status - returns all bulk account uploads that meet the required status
func (r ApiGetAllBulkAccountUploadsforUserRequest) Filter(filter float32) ApiGetAllBulkAccountUploadsforUserRequest {
	r.filter = &filter
	return r
}
// number of accounts to return, starting from first account
func (r ApiGetAllBulkAccountUploadsforUserRequest) Limit(limit float32) ApiGetAllBulkAccountUploadsforUserRequest {
	r.limit = &limit
	return r
}
// Session Authorization Token
func (r ApiGetAllBulkAccountUploadsforUserRequest) Authorization(authorization string) ApiGetAllBulkAccountUploadsforUserRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAllBulkAccountUploadsforUserRequest) ContentType(contentType string) ApiGetAllBulkAccountUploadsforUserRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAllBulkAccountUploadsforUserRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAllBulkAccountUploadsforUserExecute(r)
}

/*
GetAllBulkAccountUploadsforUser Get All Bulk Account Uploads for User

This method gets the status of all bulk account uploads that the user performed.

**Note:** Bulk account uploads are returned sorted by their creation time in descending order - from the most recent to the oldest. The bulk account uploads that are returned are ones that a specific user created and has authorization to view.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllBulkAccountUploadsforUserRequest
*/
func (a *BulkUploadOfAccountsApiService) GetAllBulkAccountUploadsforUser(ctx _context.Context) ApiGetAllBulkAccountUploadsforUserRequest {
	return ApiGetAllBulkAccountUploadsforUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BulkUploadOfAccountsApiService) GetAllBulkAccountUploadsforUserExecute(r ApiGetAllBulkAccountUploadsforUserRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadOfAccountsApiService.GetAllBulkAccountUploadsforUser")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/bulkactions/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filter == nil {
		return nil, reportError("filter is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBulkAccountUploadResultRequest struct {
	ctx _context.Context
	ApiService *BulkUploadOfAccountsApiService
	authorization *string
	contentType *string
	bulkID string
}

// Session Authorization Token
func (r ApiGetBulkAccountUploadResultRequest) Authorization(authorization string) ApiGetBulkAccountUploadResultRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetBulkAccountUploadResultRequest) ContentType(contentType string) ApiGetBulkAccountUploadResultRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetBulkAccountUploadResultRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetBulkAccountUploadResultExecute(r)
}

/*
GetBulkAccountUploadResult Get Bulk Account Upload Result

This method returns the result of the bulk account upload, which is identified by the ID of the bulk account upload. When the upload has finished, the API returns the result. The result contains a list of all the accounts that succeeded or failed to upload.
  	

**Note:** Only the user that created the bulk account upload can receive the result of the upload using this API.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bulkID
 @return ApiGetBulkAccountUploadResultRequest
*/
func (a *BulkUploadOfAccountsApiService) GetBulkAccountUploadResult(ctx _context.Context, bulkID string) ApiGetBulkAccountUploadResultRequest {
	return ApiGetBulkAccountUploadResultRequest{
		ApiService: a,
		ctx: ctx,
		bulkID: bulkID,
	}
}

// Execute executes the request
func (a *BulkUploadOfAccountsApiService) GetBulkAccountUploadResultExecute(r ApiGetBulkAccountUploadResultRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadOfAccountsApiService.GetBulkAccountUploadResult")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/bulkactions/accounts/{BulkID}"
	localVarPath = strings.Replace(localVarPath, "{"+"BulkID"+"}", _neturl.PathEscape(parameterToString(r.bulkID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
