/*
CyberArkIAG

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 18a45ad8-77e8-4ecc-873e-787c6de10a60
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// OpenIDConnectIdentityProviderApiService OpenIDConnectIdentityProviderApi service
type OpenIDConnectIdentityProviderApiService service

type ApiAddAuthenticationMethodRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	body *string
}

// Session Authorization Token
func (r ApiAddAuthenticationMethodRequest) Authorization(authorization string) ApiAddAuthenticationMethodRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddAuthenticationMethodRequest) ContentType(contentType string) ApiAddAuthenticationMethodRequest {
	r.contentType = &contentType
	return r
}
// This method adds a new authentication method. Any user who is a member of the Vault admins group can run this web service.
func (r ApiAddAuthenticationMethodRequest) Body(body string) ApiAddAuthenticationMethodRequest {
	r.body = &body
	return r
}

func (r ApiAddAuthenticationMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddAuthenticationMethodExecute(r)
}

/*
AddAuthenticationMethod Add Authentication Method

This method adds a new authentication method. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddAuthenticationMethodRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) AddAuthenticationMethod(ctx _context.Context) ApiAddAuthenticationMethodRequest {
	return ApiAddAuthenticationMethodRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) AddAuthenticationMethodExecute(r ApiAddAuthenticationMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.AddAuthenticationMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/AuthenticationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddOpenIDConnectIdentityProviderRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	body *string
}

// Session Authorization Token
func (r ApiAddOpenIDConnectIdentityProviderRequest) Authorization(authorization string) ApiAddOpenIDConnectIdentityProviderRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddOpenIDConnectIdentityProviderRequest) ContentType(contentType string) ApiAddOpenIDConnectIdentityProviderRequest {
	r.contentType = &contentType
	return r
}
// This method creates an OpenID Connect (OIDC) Identity Provider in the Vault. Any user who is a member of the Vault admins group can run this web service.  **NOTE:** This API must be used with the Add authentication method API in order to have a complete authentication configuration.  When you add an OIDC Identity Provider, you must also add the provider to the list of authentication methods using the same ID, and add the provider&#39;s base URL to the access restriction list by using the following APIs:  * Add authentication method * Add allowed referrer
func (r ApiAddOpenIDConnectIdentityProviderRequest) Body(body string) ApiAddOpenIDConnectIdentityProviderRequest {
	r.body = &body
	return r
}

func (r ApiAddOpenIDConnectIdentityProviderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddOpenIDConnectIdentityProviderExecute(r)
}

/*
AddOpenIDConnectIdentityProvider Add OpenID Connect Identity Provider

This method creates an OpenID Connect (OIDC) Identity Provider in the Vault. Any user who is a member of the Vault admins group can run this web service.

**NOTE:** This API must be used with the Add authentication method API in order to have a complete authentication configuration.

When you add an OIDC Identity Provider, you must also add the provider to the list of authentication methods using the same ID, and add the provider's base URL to the access restriction list by using the following APIs:

* Add authentication method
* Add allowed referrer

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddOpenIDConnectIdentityProviderRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) AddOpenIDConnectIdentityProvider(ctx _context.Context) ApiAddOpenIDConnectIdentityProviderRequest {
	return ApiAddOpenIDConnectIdentityProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) AddOpenIDConnectIdentityProviderExecute(r ApiAddOpenIDConnectIdentityProviderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.AddOpenIDConnectIdentityProvider")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/OIDC/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAuthenticationMethodRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
}

// Session Authorization Token
func (r ApiDeleteAuthenticationMethodRequest) Authorization(authorization string) ApiDeleteAuthenticationMethodRequest {
	r.authorization = &authorization
	return r
}
func (r ApiDeleteAuthenticationMethodRequest) ContentType(contentType string) ApiDeleteAuthenticationMethodRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteAuthenticationMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAuthenticationMethodExecute(r)
}

/*
DeleteAuthenticationMethod Delete Authentication Method

This method deletes a specific authentication method. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiDeleteAuthenticationMethodRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) DeleteAuthenticationMethod(ctx _context.Context, authID string) ApiDeleteAuthenticationMethodRequest {
	return ApiDeleteAuthenticationMethodRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) DeleteAuthenticationMethodExecute(r ApiDeleteAuthenticationMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.DeleteAuthenticationMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/AuthenticationMethods/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOpenIDConnectIdentityProviderRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
}

// Session Authorization Token
func (r ApiDeleteOpenIDConnectIdentityProviderRequest) Authorization(authorization string) ApiDeleteOpenIDConnectIdentityProviderRequest {
	r.authorization = &authorization
	return r
}
func (r ApiDeleteOpenIDConnectIdentityProviderRequest) ContentType(contentType string) ApiDeleteOpenIDConnectIdentityProviderRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteOpenIDConnectIdentityProviderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteOpenIDConnectIdentityProviderExecute(r)
}

/*
DeleteOpenIDConnectIdentityProvider Delete OpenID Connect Identity Provider

This method deletes a specific OIDC Identity Provider. Any user who is a member of the Vault admins group can run this web service.

**NOTE:** This API must be used with the Delete authentication method API in order to have a complete authentication configuration.

For example, when you delete an OIDC Identity provider, you must also delete the provider from the list of authentication methods using the same ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiDeleteOpenIDConnectIdentityProviderRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) DeleteOpenIDConnectIdentityProvider(ctx _context.Context, authID string) ApiDeleteOpenIDConnectIdentityProviderRequest {
	return ApiDeleteOpenIDConnectIdentityProviderRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) DeleteOpenIDConnectIdentityProviderExecute(r ApiDeleteOpenIDConnectIdentityProviderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.DeleteOpenIDConnectIdentityProvider")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/OIDC/Providers/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllOpenIDConnectIdentityProvidersRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
}

// Session Authorization Token
func (r ApiGetAllOpenIDConnectIdentityProvidersRequest) Authorization(authorization string) ApiGetAllOpenIDConnectIdentityProvidersRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAllOpenIDConnectIdentityProvidersRequest) ContentType(contentType string) ApiGetAllOpenIDConnectIdentityProvidersRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAllOpenIDConnectIdentityProvidersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAllOpenIDConnectIdentityProvidersExecute(r)
}

/*
GetAllOpenIDConnectIdentityProviders Get All OpenID Connect Identity Providers

This method returns a list of all OIDC Identity Providers. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllOpenIDConnectIdentityProvidersRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) GetAllOpenIDConnectIdentityProviders(ctx _context.Context) ApiGetAllOpenIDConnectIdentityProvidersRequest {
	return ApiGetAllOpenIDConnectIdentityProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) GetAllOpenIDConnectIdentityProvidersExecute(r ApiGetAllOpenIDConnectIdentityProvidersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.GetAllOpenIDConnectIdentityProviders")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/OIDC/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthenticationMethodsRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
}

// Session Authorization Token
func (r ApiGetAuthenticationMethodsRequest) Authorization(authorization string) ApiGetAuthenticationMethodsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAuthenticationMethodsRequest) ContentType(contentType string) ApiGetAuthenticationMethodsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAuthenticationMethodsRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetAuthenticationMethodsExecute(r)
}

/*
GetAuthenticationMethods Get Authentication Methods

This method returns a list of all existing authentication methods. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthenticationMethodsRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) GetAuthenticationMethods(ctx _context.Context) ApiGetAuthenticationMethodsRequest {
	return ApiGetAuthenticationMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Model200
func (a *OpenIDConnectIdentityProviderApiService) GetAuthenticationMethodsExecute(r ApiGetAuthenticationMethodsRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.GetAuthenticationMethods")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/AuthenticationMethods"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecificAuthenticationMethodRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
}

// Session Authorization Token
func (r ApiGetSpecificAuthenticationMethodRequest) Authorization(authorization string) ApiGetSpecificAuthenticationMethodRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetSpecificAuthenticationMethodRequest) ContentType(contentType string) ApiGetSpecificAuthenticationMethodRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetSpecificAuthenticationMethodRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetSpecificAuthenticationMethodExecute(r)
}

/*
GetSpecificAuthenticationMethod Get Specific Authentication Method

This method returns a specific authentication method. Any user who is a member of the Vault Admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiGetSpecificAuthenticationMethodRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) GetSpecificAuthenticationMethod(ctx _context.Context, authID string) ApiGetSpecificAuthenticationMethodRequest {
	return ApiGetSpecificAuthenticationMethodRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
//  @return Model200
func (a *OpenIDConnectIdentityProviderApiService) GetSpecificAuthenticationMethodExecute(r ApiGetSpecificAuthenticationMethodRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.GetSpecificAuthenticationMethod")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/AuthenticationMethods/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecificOpenIDConnectIdentityProviderRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
}

// Session Authorization Token
func (r ApiGetSpecificOpenIDConnectIdentityProviderRequest) Authorization(authorization string) ApiGetSpecificOpenIDConnectIdentityProviderRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetSpecificOpenIDConnectIdentityProviderRequest) ContentType(contentType string) ApiGetSpecificOpenIDConnectIdentityProviderRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetSpecificOpenIDConnectIdentityProviderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSpecificOpenIDConnectIdentityProviderExecute(r)
}

/*
GetSpecificOpenIDConnectIdentityProvider Get Specific OpenID Connect Identity Provider

This method returns a specific OIDC Identity Provider. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiGetSpecificOpenIDConnectIdentityProviderRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) GetSpecificOpenIDConnectIdentityProvider(ctx _context.Context, authID string) ApiGetSpecificOpenIDConnectIdentityProviderRequest {
	return ApiGetSpecificOpenIDConnectIdentityProviderRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) GetSpecificOpenIDConnectIdentityProviderExecute(r ApiGetSpecificOpenIDConnectIdentityProviderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.GetSpecificOpenIDConnectIdentityProvider")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/OIDC/Providers/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPTAAuthenticationRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	contentType *string
	username *string
	password *string
}

func (r ApiPTAAuthenticationRequest) ContentType(contentType string) ApiPTAAuthenticationRequest {
	r.contentType = &contentType
	return r
}
func (r ApiPTAAuthenticationRequest) Username(username string) ApiPTAAuthenticationRequest {
	r.username = &username
	return r
}
func (r ApiPTAAuthenticationRequest) Password(password string) ApiPTAAuthenticationRequest {
	r.password = &password
	return r
}

func (r ApiPTAAuthenticationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PTAAuthenticationExecute(r)
}

/*
PTAAuthentication PTA Authentication

This method enables a user to get a token upon Web application authentication. You can use this method to monitor the PTA system health, as shown in [Get PTA replication status](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/WebServices/PTA_System_Health.htm).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPTAAuthenticationRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) PTAAuthentication(ctx _context.Context) ApiPTAAuthenticationRequest {
	return ApiPTAAuthenticationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) PTAAuthenticationExecute(r ApiPTAAuthenticationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.PTAAuthentication")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/getauthtoken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.username == nil {
		return nil, reportError("username is required and must be specified")
	}
	if r.password == nil {
		return nil, reportError("password is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	localVarFormParams.Add("username", parameterToString(*r.username, ""))
	localVarFormParams.Add("password", parameterToString(*r.password, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAuthenticationMethodRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
	body *string
}

// Session Authorization Token
func (r ApiUpdateAuthenticationMethodRequest) Authorization(authorization string) ApiUpdateAuthenticationMethodRequest {
	r.authorization = &authorization
	return r
}
func (r ApiUpdateAuthenticationMethodRequest) ContentType(contentType string) ApiUpdateAuthenticationMethodRequest {
	r.contentType = &contentType
	return r
}
// This method updates the properties for a specific authentication method. Any user who is a member of the Vault admins group can run this web service.
func (r ApiUpdateAuthenticationMethodRequest) Body(body string) ApiUpdateAuthenticationMethodRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAuthenticationMethodRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateAuthenticationMethodExecute(r)
}

/*
UpdateAuthenticationMethod Update Authentication Method

This method updates the properties for a specific authentication method. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiUpdateAuthenticationMethodRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) UpdateAuthenticationMethod(ctx _context.Context, authID string) ApiUpdateAuthenticationMethodRequest {
	return ApiUpdateAuthenticationMethodRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) UpdateAuthenticationMethodExecute(r ApiUpdateAuthenticationMethodRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.UpdateAuthenticationMethod")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/AuthenticationMethods/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateOpenIDConnectIdentityProviderRequest struct {
	ctx _context.Context
	ApiService *OpenIDConnectIdentityProviderApiService
	authorization *string
	contentType *string
	authID string
	body *string
}

// Session Authorization Token
func (r ApiUpdateOpenIDConnectIdentityProviderRequest) Authorization(authorization string) ApiUpdateOpenIDConnectIdentityProviderRequest {
	r.authorization = &authorization
	return r
}
func (r ApiUpdateOpenIDConnectIdentityProviderRequest) ContentType(contentType string) ApiUpdateOpenIDConnectIdentityProviderRequest {
	r.contentType = &contentType
	return r
}
// This method updates an existing OIDC Identity Provider. Any user who is a member of the Vault admins group can run this web service.
func (r ApiUpdateOpenIDConnectIdentityProviderRequest) Body(body string) ApiUpdateOpenIDConnectIdentityProviderRequest {
	r.body = &body
	return r
}

func (r ApiUpdateOpenIDConnectIdentityProviderRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateOpenIDConnectIdentityProviderExecute(r)
}

/*
UpdateOpenIDConnectIdentityProvider Update OpenID Connect Identity Provider

This method updates an existing OIDC Identity Provider. Any user who is a member of the Vault admins group can run this web service.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param authID
 @return ApiUpdateOpenIDConnectIdentityProviderRequest
*/
func (a *OpenIDConnectIdentityProviderApiService) UpdateOpenIDConnectIdentityProvider(ctx _context.Context, authID string) ApiUpdateOpenIDConnectIdentityProviderRequest {
	return ApiUpdateOpenIDConnectIdentityProviderRequest{
		ApiService: a,
		ctx: ctx,
		authID: authID,
	}
}

// Execute executes the request
func (a *OpenIDConnectIdentityProviderApiService) UpdateOpenIDConnectIdentityProviderExecute(r ApiUpdateOpenIDConnectIdentityProviderRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OpenIDConnectIdentityProviderApiService.UpdateOpenIDConnectIdentityProvider")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Configuration/OIDC/Providers/{authID}"
	localVarPath = strings.Replace(localVarPath, "{"+"authID"+"}", _neturl.PathEscape(parameterToString(r.authID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
