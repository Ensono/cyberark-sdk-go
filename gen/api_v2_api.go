/*
CyberArkIAG

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 18a45ad8-77e8-4ecc-873e-787c6de10a60
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// V2APIApiService V2APIApi service
type V2APIApiService service

type ApiAddAccountRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	body *string
}

func (r ApiAddAccountRequest) Authorization(authorization string) ApiAddAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddAccountRequest) ContentType(contentType string) ApiAddAccountRequest {
	r.contentType = &contentType
	return r
}
// This method adds a new privileged account or SSH key to the Vault.  To run this web service, a user requires the following permission in the Vault:  * Add account  AND either  * Update password  OR  * Update password properties  **Note:** You require an additional license to add SSH keys to the Vault. For more information, contact your CyberArk representative.
func (r ApiAddAccountRequest) Body(body string) ApiAddAccountRequest {
	r.body = &body
	return r
}

func (r ApiAddAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddAccountExecute(r)
}

/*
AddAccount Add Account

This method adds a new privileged account or SSH key to the Vault.

To run this web service, a user requires the following permission in the Vault:

* Add account

AND either

* Update password

OR

* Update password properties

**Note:** You require an additional license to add SSH keys to the Vault. For more information, contact your CyberArk representative.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddAccountRequest
*/
func (a *V2APIApiService) AddAccount(ctx _context.Context) ApiAddAccountRequest {
	return ApiAddAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2APIApiService) AddAccountExecute(r ApiAddAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.AddAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddPendingAccountRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	body *string
}

func (r ApiAddPendingAccountRequest) Authorization(authorization string) ApiAddPendingAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddPendingAccountRequest) ContentType(contentType string) ApiAddPendingAccountRequest {
	r.contentType = &contentType
	return r
}
// This method enables an account or SSH key that is discovered by an external scanner to be added as a pending account to the Accounts Feed. This facilitates the privileged account workflow, during which users can identify privileged accounts and determine which are onboarded to the Vault.  **Note:** In order to add SSH keys to the Vault, you require an additional license. For more information, contact your CyberArk representative.
func (r ApiAddPendingAccountRequest) Body(body string) ApiAddPendingAccountRequest {
	r.body = &body
	return r
}

func (r ApiAddPendingAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddPendingAccountExecute(r)
}

/*
AddPendingAccount Add Pending Account

This method enables an account or SSH key that is discovered by an external scanner to be added as a pending account to the Accounts Feed. This facilitates the privileged account workflow, during which users can identify privileged accounts and determine which are onboarded to the Vault.

**Note:** In order to add SSH keys to the Vault, you require an additional license. For more information, contact your CyberArk representative.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddPendingAccountRequest
*/
func (a *V2APIApiService) AddPendingAccount(ctx _context.Context) ApiAddPendingAccountRequest {
	return ApiAddPendingAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2APIApiService) AddPendingAccountExecute(r ApiAddPendingAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.AddPendingAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/WebServices/PIMServices.svc/PendingAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAccountRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiDeleteAccountRequest) Authorization(authorization string) ApiDeleteAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiDeleteAccountRequest) ContentType(contentType string) ApiDeleteAccountRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Delete Account

This method deletes a specific account in the Vault.

The user who runs this web service requires **Delete Accounts** permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiDeleteAccountRequest
*/
func (a *V2APIApiService) DeleteAccount(ctx _context.Context, accountID string) ApiDeleteAccountRequest {
	return ApiDeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *V2APIApiService) DeleteAccountExecute(r ApiDeleteAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.DeleteAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExtendedAccountOverviewRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
}

// Session Authorization Token
func (r ApiExtendedAccountOverviewRequest) Authorization(authorization string) ApiExtendedAccountOverviewRequest {
	r.authorization = &authorization
	return r
}
func (r ApiExtendedAccountOverviewRequest) ContentType(contentType string) ApiExtendedAccountOverviewRequest {
	r.contentType = &contentType
	return r
}

func (r ApiExtendedAccountOverviewRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ExtendedAccountOverviewExecute(r)
}

/*
ExtendedAccountOverview Extended Account Overview

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiExtendedAccountOverviewRequest
*/
func (a *V2APIApiService) ExtendedAccountOverview(ctx _context.Context, accountID string) ApiExtendedAccountOverviewRequest {
	return ApiExtendedAccountOverviewRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *V2APIApiService) ExtendedAccountOverviewExecute(r ApiExtendedAccountOverviewRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.ExtendedAccountOverview")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/ExtendedAccounts/{AccountID}/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAccountActivityRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiGetAccountActivityRequest) Authorization(authorization string) ApiGetAccountActivityRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAccountActivityRequest) ContentType(contentType string) ApiGetAccountActivityRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAccountActivityRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetAccountActivityExecute(r)
}

/*
GetAccountActivity Get Account Activity

This method returns the activities of a specific account that is identified by its account ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiGetAccountActivityRequest
*/
func (a *V2APIApiService) GetAccountActivity(ctx _context.Context, accountID string) ApiGetAccountActivityRequest {
	return ApiGetAccountActivityRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Model200
func (a *V2APIApiService) GetAccountActivityExecute(r ApiGetAccountActivityRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.GetAccountActivity")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/WebServices/PIMServices.svc/Accounts/{AccountID}/Activities"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountDetailsRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiGetAccountDetailsRequest) Authorization(authorization string) ApiGetAccountDetailsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAccountDetailsRequest) ContentType(contentType string) ApiGetAccountDetailsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAccountDetailsRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetAccountDetailsExecute(r)
}

/*
GetAccountDetails Get Account Details

This method returns information about an account identified by its ID.

The user who runs this web service requires **List Accounts** permissions in the Safe where the account is located inside the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiGetAccountDetailsRequest
*/
func (a *V2APIApiService) GetAccountDetails(ctx _context.Context, accountID string) ApiGetAccountDetailsRequest {
	return ApiGetAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Model200
func (a *V2APIApiService) GetAccountDetailsExecute(r ApiGetAccountDetailsRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.GetAccountDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountsRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	search *string
	searchType *string
	sort *string
	offset *float32
	limit *float32
	filter *string
	contentType *string
	authorization *string
}

// List of keywords to search for in accounts, separated by a space.
func (r ApiGetAccountsRequest) Search(search string) ApiGetAccountsRequest {
	r.search = &search
	return r
}
// Get accounts that either contain or start with the value specified in the Search parameter. Valid values: contains (default) or startswith.
func (r ApiGetAccountsRequest) SearchType(searchType string) ApiGetAccountsRequest {
	r.searchType = &searchType
	return r
}
// Property or properties by which to sort returned accounts, followed by asc (default) or desc to control sort direction. Separate multiple properties with commas, up to a maximum of three properties.
func (r ApiGetAccountsRequest) Sort(sort string) ApiGetAccountsRequest {
	r.sort = &sort
	return r
}
// Offset of the first account that is returned in the collection of results.
func (r ApiGetAccountsRequest) Offset(offset float32) ApiGetAccountsRequest {
	r.offset = &offset
	return r
}
// Maximum number of returned accounts. If not specified, the default value is 50. The maximum number that can be specified is 1000.
func (r ApiGetAccountsRequest) Limit(limit float32) ApiGetAccountsRequest {
	r.limit = &limit
	return r
}
// Get accounts from a specific safe, using the safe name.
func (r ApiGetAccountsRequest) Filter(filter string) ApiGetAccountsRequest {
	r.filter = &filter
	return r
}
func (r ApiGetAccountsRequest) ContentType(contentType string) ApiGetAccountsRequest {
	r.contentType = &contentType
	return r
}
func (r ApiGetAccountsRequest) Authorization(authorization string) ApiGetAccountsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetAccountsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetAccountsExecute(r)
}

/*
GetAccounts Get Accounts

This method returns a list of all the accounts in the Vault.

The user who runs this web service requires **List Accounts** permissions in the Safe.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountsRequest
*/
func (a *V2APIApiService) GetAccounts(ctx _context.Context) ApiGetAccountsRequest {
	return ApiGetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *V2APIApiService) GetAccountsExecute(r ApiGetAccountsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.GetAccounts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.search == nil {
		return nil, reportError("search is required and must be specified")
	}
	if r.searchType == nil {
		return nil, reportError("searchType is required and must be specified")
	}
	if r.sort == nil {
		return nil, reportError("sort is required and must be specified")
	}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}
	if r.filter == nil {
		return nil, reportError("filter is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	localVarQueryParams.Add("searchType", parameterToString(*r.searchType, ""))
	localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLinkanAccountRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

// Session Authorization Token
func (r ApiLinkanAccountRequest) Authorization(authorization string) ApiLinkanAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiLinkanAccountRequest) ContentType(contentType string) ApiLinkanAccountRequest {
	r.contentType = &contentType
	return r
}
// This method enables a user to associate a linked account to an existing source account. The linked account can be a Reconcile account, Logon account, or other type of linked account that is defined in the platform configuration.     _**Note:** The type of linked accounts that are allowed are determined by the Platform settings. Each platform can support different types of linked accounts._  To run this service, the user must have the following Safe member authorizations:  * List accounts - For both the Safe of the linked account and the Safe of the source account * Update account properties - For the Safe of the source account
func (r ApiLinkanAccountRequest) Body(body string) ApiLinkanAccountRequest {
	r.body = &body
	return r
}

func (r ApiLinkanAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.LinkanAccountExecute(r)
}

/*
LinkanAccount Link an Account

This method enables a user to associate a linked account to an existing source account. The linked account can be a Reconcile account, Logon account, or other type of linked account that is defined in the platform configuration.
  	
_**Note:** The type of linked accounts that are allowed are determined by the Platform settings. Each platform can support different types of linked accounts._

To run this service, the user must have the following Safe member authorizations:

* List accounts - For both the Safe of the linked account and the Safe of the source account
* Update account properties - For the Safe of the source account

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiLinkanAccountRequest
*/
func (a *V2APIApiService) LinkanAccount(ctx _context.Context, accountID string) ApiLinkanAccountRequest {
	return ApiLinkanAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *V2APIApiService) LinkanAccountExecute(r ApiLinkanAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.LinkanAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}/LinkAccount"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx _context.Context
	ApiService *V2APIApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiUpdateAccountRequest) Authorization(authorization string) ApiUpdateAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiUpdateAccountRequest) ContentType(contentType string) ApiUpdateAccountRequest {
	r.contentType = &contentType
	return r
}
// This method updates an existing account&#39;s details. It is not mandatory to send all the account’s details. Any changed values sent in the request will be updated. All other properties values will remain the same.  On each property, the following operations can be performed:  * Replace - replace the existing value of a property * Remove (to remove the property from the account) * Add (to add that property to the account)  It is possible to set several properties using the same command using the following structure:  &#x60;&#x60;&#x60;json [  {      \&quot;op\&quot;: \&quot;replace\&quot;,      \&quot;path\&quot;: \&quot;/platformaccountproperties\&quot;,      \&quot;value\&quot;: \&quot;{          \\\&quot;{PropertyID1}\\\&quot;:\\\&quot;{Value}\\\&quot;,          \\\&quot;{PropertyID2}\\\&quot;:\\\&quot;{Value}\\\&quot;,          \\\&quot;{PropertyID3}\\\&quot;:\\\&quot;{Value}\\\&quot;      }\&quot;  } ] &#x60;&#x60;&#x60;  When sending several operations on the same property, only the last operation will affect the property.
func (r ApiUpdateAccountRequest) Body(body string) ApiUpdateAccountRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAccountRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Update Account

This method updates an existing account's details. It is not mandatory to send all the account’s details. Any changed values sent in the request will be updated. All other properties values will remain the same.

On each property, the following operations can be performed:

* Replace - replace the existing value of a property
* Remove (to remove the property from the account)
* Add (to add that property to the account)

It is possible to set several properties using the same command using the following structure:

```json
[
	{
	    "op": "replace",
	    "path": "/platformaccountproperties",
	    "value": "{
	        \"{PropertyID1}\":\"{Value}\",
	        \"{PropertyID2}\":\"{Value}\",
	        \"{PropertyID3}\":\"{Value}\"
	    }"
	}
]
```

When sending several operations on the same property, only the last operation will affect the property.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiUpdateAccountRequest
*/
func (a *V2APIApiService) UpdateAccount(ctx _context.Context, accountID string) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
//  @return Model200
func (a *V2APIApiService) UpdateAccountExecute(r ApiUpdateAccountRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "V2APIApiService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
