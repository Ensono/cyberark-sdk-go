/*
CyberArkIAG

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 18a45ad8-77e8-4ecc-873e-787c6de10a60
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiAdHocConnectthroughPSMRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	body *string
}

func (r ApiAdHocConnectthroughPSMRequest) Authorization(authorization string) ApiAdHocConnectthroughPSMRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAdHocConnectthroughPSMRequest) ContentType(contentType string) ApiAdHocConnectthroughPSMRequest {
	r.contentType = &contentType
	return r
}
// This method allows you to connect through PSM without using an existing account, by returning settings that can be used with an RDP client application or for the HTML5 gateway.  You must enable Privileged Session Monitoring and ad-hoc connection via PVWA configuration. For more details, see [Ad Hoc Connections](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/PASIMP/Configuring-Secure-Connect.htm).
func (r ApiAdHocConnectthroughPSMRequest) Body(body string) ApiAdHocConnectthroughPSMRequest {
	r.body = &body
	return r
}

func (r ApiAdHocConnectthroughPSMRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AdHocConnectthroughPSMExecute(r)
}

/*
AdHocConnectthroughPSM Ad-Hoc Connect through PSM

This method allows you to connect through PSM without using an existing account, by returning settings that can be used with an RDP client application or for the HTML5 gateway.

You must enable Privileged Session Monitoring and ad-hoc connection via PVWA configuration. For more details, see [Ad Hoc Connections](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/PASIMP/Configuring-Secure-Connect.htm).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAdHocConnectthroughPSMRequest
*/
func (a *DefaultApiService) AdHocConnectthroughPSM(ctx _context.Context) ApiAdHocConnectthroughPSMRequest {
	return ApiAdHocConnectthroughPSMRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AdHocConnectthroughPSMExecute(r ApiAdHocConnectthroughPSMRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AdHocConnectthroughPSM")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/AdHocConnect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddDiscoveredAccountsV108Request struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	body *string
}

func (r ApiAddDiscoveredAccountsV108Request) Authorization(authorization string) ApiAddDiscoveredAccountsV108Request {
	r.authorization = &authorization
	return r
}
func (r ApiAddDiscoveredAccountsV108Request) ContentType(contentType string) ApiAddDiscoveredAccountsV108Request {
	r.contentType = &contentType
	return r
}
// This method adds newly discovered accounts and their dependencies.  | Action | Description | | --- | --- | | Discovered account | Discovered accounts are added to the Pending Accounts list. | | Discovered dependency | Discovered dependencies are added to the Pending Accounts list or are automatically added to the corresponding master account that has already been onboarded. | | Automatic onboarding | Discovered accounts are onboarded according to matching onboarding rules. If automatic onboarding fails for any reason, the account is added to the Pending Accounts list. |  Currently, Private SSH Keys are not supported.  The user who runs this web service requires the following users and permissions:  To add pending accounts:  * **User:** Owner of PasswordManager_Pending Safe * **Permissions:**   * Add account   * List files   * Update account properties  To onboard the account:  * **User:** Owner of the target Safe of the onboarding rule. * **Permissions:**   * Add account   * Update account properties   * Initiate CPM account management operations
func (r ApiAddDiscoveredAccountsV108Request) Body(body string) ApiAddDiscoveredAccountsV108Request {
	r.body = &body
	return r
}

func (r ApiAddDiscoveredAccountsV108Request) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddDiscoveredAccountsV108Execute(r)
}

/*
AddDiscoveredAccountsV108 Add Discovered Accounts (v10.8+)

This method adds newly discovered accounts and their dependencies.

| Action | Description |
| --- | --- |
| Discovered account | Discovered accounts are added to the Pending Accounts list. |
| Discovered dependency | Discovered dependencies are added to the Pending Accounts list or are automatically added to the corresponding master account that has already been onboarded. |
| Automatic onboarding | Discovered accounts are onboarded according to matching onboarding rules. If automatic onboarding fails for any reason, the account is added to the Pending Accounts list. |

Currently, Private SSH Keys are not supported.

The user who runs this web service requires the following users and permissions:

To add pending accounts:

* **User:** Owner of PasswordManager_Pending Safe
* **Permissions:**
  * Add account
  * List files
  * Update account properties

To onboard the account:

* **User:** Owner of the target Safe of the onboarding rule.
* **Permissions:**
  * Add account
  * Update account properties
  * Initiate CPM account management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddDiscoveredAccountsV108Request
*/
func (a *DefaultApiService) AddDiscoveredAccountsV108(ctx _context.Context) ApiAddDiscoveredAccountsV108Request {
	return ApiAddDiscoveredAccountsV108Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddDiscoveredAccountsV108Execute(r ApiAddDiscoveredAccountsV108Request) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddDiscoveredAccountsV108")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/DiscoveredAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddSafeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	body *string
}

func (r ApiAddSafeRequest) Authorization(authorization string) ApiAddSafeRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddSafeRequest) ContentType(contentType string) ApiAddSafeRequest {
	r.contentType = &contentType
	return r
}
// This method adds a new Safe to the Vault.  The user who runs this web service requires **Add Safes** permissions in the Vault.
func (r ApiAddSafeRequest) Body(body string) ApiAddSafeRequest {
	r.body = &body
	return r
}

func (r ApiAddSafeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddSafeExecute(r)
}

/*
AddSafe Add Safe

This method adds a new Safe to the Vault.

The user who runs this web service requires **Add Safes** permissions in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddSafeRequest
*/
func (a *DefaultApiService) AddSafe(ctx _context.Context) ApiAddSafeRequest {
	return ApiAddSafeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddSafeExecute(r ApiAddSafeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSafe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddSafeMemberRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	safe string
	body *string
}

// Session Authorization Token
func (r ApiAddSafeMemberRequest) Authorization(authorization string) ApiAddSafeMemberRequest {
	r.authorization = &authorization
	return r
}
func (r ApiAddSafeMemberRequest) ContentType(contentType string) ApiAddSafeMemberRequest {
	r.contentType = &contentType
	return r
}
// This method adds an existing user or group as a Safe member.  The user who runs this web service requires the following permissions in the Vault:  * Manage Safe Members
func (r ApiAddSafeMemberRequest) Body(body string) ApiAddSafeMemberRequest {
	r.body = &body
	return r
}

func (r ApiAddSafeMemberRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.AddSafeMemberExecute(r)
}

/*
AddSafeMember Add Safe Member

This method adds an existing user or group as a Safe member.

The user who runs this web service requires the following permissions in the Vault:

* Manage Safe Members

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safe
 @return ApiAddSafeMemberRequest
*/
func (a *DefaultApiService) AddSafeMember(ctx _context.Context, safe string) ApiAddSafeMemberRequest {
	return ApiAddSafeMemberRequest{
		ApiService: a,
		ctx: ctx,
		safe: safe,
	}
}

// Execute executes the request
func (a *DefaultApiService) AddSafeMemberExecute(r ApiAddSafeMemberRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.AddSafeMember")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes/{Safe}/Members"
	localVarPath = strings.Replace(localVarPath, "{"+"Safe"+"}", _neturl.PathEscape(parameterToString(r.safe, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangePasswordRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiChangePasswordRequest) Authorization(authorization string) ApiChangePasswordRequest {
	r.authorization = &authorization
	return r
}
func (r ApiChangePasswordRequest) ContentType(contentType string) ApiChangePasswordRequest {
	r.contentType = &contentType
	return r
}
// This method marks the account for an immediate password change by the CPM to a new random password.  The user who runs this web service requires the following permission in the Safe where the privileged account is stored:  * Initiate CPM password management operations
func (r ApiChangePasswordRequest) Body(body string) ApiChangePasswordRequest {
	r.body = &body
	return r
}

func (r ApiChangePasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChangePasswordExecute(r)
}

/*
ChangePassword Change Password

This method marks the account for an immediate password change by the CPM to a new random password.

The user who runs this web service requires the following permission in the Safe where the privileged account is stored:

* Initiate CPM password management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiChangePasswordRequest
*/
func (a *DefaultApiService) ChangePassword(ctx _context.Context, accountID string) ApiChangePasswordRequest {
	return ApiChangePasswordRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ChangePasswordExecute(r ApiChangePasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangePassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/WebServices/PIMServices.svc/Accounts/{AccountID}/ChangeCredentials"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangePasswordImmediatelyRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiChangePasswordImmediatelyRequest) Authorization(authorization string) ApiChangePasswordImmediatelyRequest {
	r.authorization = &authorization
	return r
}
func (r ApiChangePasswordImmediatelyRequest) ContentType(contentType string) ApiChangePasswordImmediatelyRequest {
	r.contentType = &contentType
	return r
}
// This method marks an account for an immediate credentials change by the CPM to a new random value.  The user who runs this web service requires the following permission in the Safe where the privileged account is stored:  * Initiate CPM password management operations
func (r ApiChangePasswordImmediatelyRequest) Body(body string) ApiChangePasswordImmediatelyRequest {
	r.body = &body
	return r
}

func (r ApiChangePasswordImmediatelyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChangePasswordImmediatelyExecute(r)
}

/*
ChangePasswordImmediately Change Password Immediately

This method marks an account for an immediate credentials change by the CPM to a new random value.

The user who runs this web service requires the following permission in the Safe where the privileged account is stored:

* Initiate CPM password management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiChangePasswordImmediatelyRequest
*/
func (a *DefaultApiService) ChangePasswordImmediately(ctx _context.Context, accountID string) ApiChangePasswordImmediatelyRequest {
	return ApiChangePasswordImmediatelyRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ChangePasswordImmediatelyExecute(r ApiChangePasswordImmediatelyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangePasswordImmediately")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Accounts/{AccountID}/Change"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangePasswordSetNextPasswordRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiChangePasswordSetNextPasswordRequest) Authorization(authorization string) ApiChangePasswordSetNextPasswordRequest {
	r.authorization = &authorization
	return r
}
func (r ApiChangePasswordSetNextPasswordRequest) ContentType(contentType string) ApiChangePasswordSetNextPasswordRequest {
	r.contentType = &contentType
	return r
}
// This method enables users to set the account&#39;s credentials to use for the next CPM change.  The user who runs this web service requires the following permissions in the Safe where the privileged account is stored:  * Initiate CPM password management operations * Specify next password value
func (r ApiChangePasswordSetNextPasswordRequest) Body(body string) ApiChangePasswordSetNextPasswordRequest {
	r.body = &body
	return r
}

func (r ApiChangePasswordSetNextPasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChangePasswordSetNextPasswordExecute(r)
}

/*
ChangePasswordSetNextPassword Change Password, Set Next Password

This method enables users to set the account's credentials to use for the next CPM change.

The user who runs this web service requires the following permissions in the Safe where the privileged account is stored:

* Initiate CPM password management operations
* Specify next password value

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiChangePasswordSetNextPasswordRequest
*/
func (a *DefaultApiService) ChangePasswordSetNextPassword(ctx _context.Context, accountID string) ApiChangePasswordSetNextPasswordRequest {
	return ApiChangePasswordSetNextPasswordRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ChangePasswordSetNextPasswordExecute(r ApiChangePasswordSetNextPasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangePasswordSetNextPassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/Accounts/{AccountID}/SetNextPassword"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiChangePasswordintheVaultOnlyRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiChangePasswordintheVaultOnlyRequest) Authorization(authorization string) ApiChangePasswordintheVaultOnlyRequest {
	r.authorization = &authorization
	return r
}
func (r ApiChangePasswordintheVaultOnlyRequest) ContentType(contentType string) ApiChangePasswordintheVaultOnlyRequest {
	r.contentType = &contentType
	return r
}
// This method enables users to set account credentials and change them in the Vault. This will not affect credentials on the target device.  The user who runs this web service requires **Update password value** permission in the Safe where the privileged account is stored.
func (r ApiChangePasswordintheVaultOnlyRequest) Body(body string) ApiChangePasswordintheVaultOnlyRequest {
	r.body = &body
	return r
}

func (r ApiChangePasswordintheVaultOnlyRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ChangePasswordintheVaultOnlyExecute(r)
}

/*
ChangePasswordintheVaultOnly Change Password in the Vault Only

This method enables users to set account credentials and change them in the Vault. This will not affect credentials on the target device.

The user who runs this web service requires **Update password value** permission in the Safe where the privileged account is stored.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiChangePasswordintheVaultOnlyRequest
*/
func (a *DefaultApiService) ChangePasswordintheVaultOnly(ctx _context.Context, accountID string) ApiChangePasswordintheVaultOnlyRequest {
	return ApiChangePasswordintheVaultOnlyRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ChangePasswordintheVaultOnlyExecute(r ApiChangePasswordintheVaultOnlyRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ChangePasswordintheVaultOnly")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}/Password/Update"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCheckInanExclusiveAccountRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiCheckInanExclusiveAccountRequest) Authorization(authorization string) ApiCheckInanExclusiveAccountRequest {
	r.authorization = &authorization
	return r
}
func (r ApiCheckInanExclusiveAccountRequest) ContentType(contentType string) ApiCheckInanExclusiveAccountRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCheckInanExclusiveAccountRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CheckInanExclusiveAccountExecute(r)
}

/*
CheckInanExclusiveAccount Check In an Exclusive Account

This method checks an exclusive account into the Vault.

* If the account is managed automatically by the CPM, after it is checked in, the password is changed immediately.
* If the account is managed manually, a notification is sent to a user who is authorized to change the password. The account is checked in automatically after it has been changed.

The user who runs this web service requires the following permission in the Safe where the privileged account is stored:

* Initiate CPM password management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiCheckInanExclusiveAccountRequest
*/
func (a *DefaultApiService) CheckInanExclusiveAccount(ctx _context.Context, accountID string) ApiCheckInanExclusiveAccountRequest {
	return ApiCheckInanExclusiveAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) CheckInanExclusiveAccountExecute(r ApiCheckInanExclusiveAccountRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CheckInanExclusiveAccount")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Accounts/{AccountID}/CheckIn"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConnectUsingPSMRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accept *string
	accountID string
	body *string
}

func (r ApiConnectUsingPSMRequest) Authorization(authorization string) ApiConnectUsingPSMRequest {
	r.authorization = &authorization
	return r
}
func (r ApiConnectUsingPSMRequest) ContentType(contentType string) ApiConnectUsingPSMRequest {
	r.contentType = &contentType
	return r
}
func (r ApiConnectUsingPSMRequest) Accept(accept string) ApiConnectUsingPSMRequest {
	r.accept = &accept
	return r
}
// This method enables you to connect to an account through PSM (PSMConnect) using a connection method defined in the PVWA.  A response header defines which connection method is returned.  For more information, refer to [Privileged Session Management Interface](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/PASIMP/Configuring-the-Privileged-Session-Management-Interface.htm).  ## Header Parameter  Parameter: Accept  Type: String  Description: The table below describes the expected response format depending on the value of the Accept header in the request, per connection method configuration (RDP File or PSM Gateway).  | PVWA configuration | Optional values | Connection method | | --- | --- | --- | | RDP | application/json, application/octet-stream (default), &#x60;*_/ *&#x60; | RDPFile (JSON), RDPFile (octet-stream raw) | | PSMGW | &#x60;* / *&#x60; | PSMGW (JSON) - Returns the HTML5 connection data. |  **Note:** To use PSMGW, PSMGW must be configured before using this REST API in order to receive a PSMGW response.
func (r ApiConnectUsingPSMRequest) Body(body string) ApiConnectUsingPSMRequest {
	r.body = &body
	return r
}

func (r ApiConnectUsingPSMRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ConnectUsingPSMExecute(r)
}

/*
ConnectUsingPSM Connect Using PSM

This method enables you to connect to an account through PSM (PSMConnect) using a connection method defined in the PVWA.

A response header defines which connection method is returned.

For more information, refer to [Privileged Session Management Interface](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/Latest/en/Content/PASIMP/Configuring-the-Privileged-Session-Management-Interface.htm).

## Header Parameter

Parameter: Accept

Type: String

Description: The table below describes the expected response format depending on the value of the Accept header in the request, per connection method configuration (RDP File or PSM Gateway).

| PVWA configuration | Optional values | Connection method |
| --- | --- | --- |
| RDP | application/json, application/octet-stream (default), `*/ *` | RDPFile (JSON), RDPFile (octet-stream raw) |
| PSMGW | `* / *` | PSMGW (JSON) - Returns the HTML5 connection data. |

**Note:** To use PSMGW, PSMGW must be configured before using this REST API in order to receive a PSMGW response.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiConnectUsingPSMRequest
*/
func (a *DefaultApiService) ConnectUsingPSM(ctx _context.Context, accountID string) ApiConnectUsingPSMRequest {
	return ApiConnectUsingPSMRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ConnectUsingPSMExecute(r ApiConnectUsingPSMRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ConnectUsingPSM")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Accounts/{AccountID}/PSMConnect"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSafeRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	safe string
}

func (r ApiDeleteSafeRequest) Authorization(authorization string) ApiDeleteSafeRequest {
	r.authorization = &authorization
	return r
}
func (r ApiDeleteSafeRequest) ContentType(contentType string) ApiDeleteSafeRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteSafeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSafeExecute(r)
}

/*
DeleteSafe Delete Safe

This method deletes a Safe from the Vault.

The user who runs this web service requires **Manage Safe** permissions on the required Safe.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safe
 @return ApiDeleteSafeRequest
*/
func (a *DefaultApiService) DeleteSafe(ctx _context.Context, safe string) ApiDeleteSafeRequest {
	return ApiDeleteSafeRequest{
		ApiService: a,
		ctx: ctx,
		safe: safe,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSafeExecute(r ApiDeleteSafeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSafe")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes/{Safe}"
	localVarPath = strings.Replace(localVarPath, "{"+"Safe"+"}", _neturl.PathEscape(parameterToString(r.safe, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllSafesRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	search *string
	offset *float32
	limit *float32
	sort *string
	includeAccounts *string
	extendedDetails *string
	authorization *string
	contentType *string
}

// Searches according to the Safe name. Search is performed according to the REST standard (search&#x3D;\&quot;search word\&quot;).
func (r ApiGetAllSafesRequest) Search(search string) ApiGetAllSafesRequest {
	r.search = &search
	return r
}
// Offset of the first Safe that is returned in the collection of results.
func (r ApiGetAllSafesRequest) Offset(offset float32) ApiGetAllSafesRequest {
	r.offset = &offset
	return r
}
// The maximum number of Safes that are returned. When used together with the offset parameter, this value determines the number of Safes to return, starting from the first Safe that is returned.
func (r ApiGetAllSafesRequest) Limit(limit float32) ApiGetAllSafesRequest {
	r.limit = &limit
	return r
}
// Sorts according to the safeName property in ascending order (default) or descending order to control the sort direction.
func (r ApiGetAllSafesRequest) Sort(sort string) ApiGetAllSafesRequest {
	r.sort = &sort
	return r
}
// Whether or not to return accounts for each Safe as part of the response. If not sent, the value is False.
func (r ApiGetAllSafesRequest) IncludeAccounts(includeAccounts string) ApiGetAllSafesRequest {
	r.includeAccounts = &includeAccounts
	return r
}
// Whether or not to return all Safe details or only safeName as part of the response. If not sent, the value is True.
func (r ApiGetAllSafesRequest) ExtendedDetails(extendedDetails string) ApiGetAllSafesRequest {
	r.extendedDetails = &extendedDetails
	return r
}
func (r ApiGetAllSafesRequest) Authorization(authorization string) ApiGetAllSafesRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetAllSafesRequest) ContentType(contentType string) ApiGetAllSafesRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetAllSafesRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetAllSafesExecute(r)
}

/*
GetAllSafes Get All Safes

This method returns a list of all Safes in the Vault that the user has permissions for. To run this web user, the user must be a member of the Safes in the Vault that are returned in the list.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllSafesRequest
*/
func (a *DefaultApiService) GetAllSafes(ctx _context.Context) ApiGetAllSafesRequest {
	return ApiGetAllSafesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Model200
func (a *DefaultApiService) GetAllSafesExecute(r ApiGetAllSafesRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetAllSafes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.search == nil {
		return localVarReturnValue, nil, reportError("search is required and must be specified")
	}
	if r.offset == nil {
		return localVarReturnValue, nil, reportError("offset is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.sort == nil {
		return localVarReturnValue, nil, reportError("sort is required and must be specified")
	}
	if r.includeAccounts == nil {
		return localVarReturnValue, nil, reportError("includeAccounts is required and must be specified")
	}
	if r.extendedDetails == nil {
		return localVarReturnValue, nil, reportError("extendedDetails is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	localVarQueryParams.Add("includeAccounts", parameterToString(*r.includeAccounts, ""))
	localVarQueryParams.Add("extendedDetails", parameterToString(*r.extendedDetails, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiscoveredAccountDetailsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
}

// Session Authorization Token
func (r ApiGetDiscoveredAccountDetailsRequest) Authorization(authorization string) ApiGetDiscoveredAccountDetailsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetDiscoveredAccountDetailsRequest) ContentType(contentType string) ApiGetDiscoveredAccountDetailsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetDiscoveredAccountDetailsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDiscoveredAccountDetailsExecute(r)
}

/*
GetDiscoveredAccountDetails Get Discovered Account Details

This method returns information about a discovered account and its dependencies from the Pending Accounts list. The discovered account is identified by its ID.

To run this web service, the user must be a member of the Vault admins group.

**Note:** Discovered accounts that were onboarded either manually or automatically, according to predefined rules, won't be returned using this method.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiGetDiscoveredAccountDetailsRequest
*/
func (a *DefaultApiService) GetDiscoveredAccountDetails(ctx _context.Context, accountID string) ApiGetDiscoveredAccountDetailsRequest {
	return ApiGetDiscoveredAccountDetailsRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetDiscoveredAccountDetailsExecute(r ApiGetDiscoveredAccountDetailsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDiscoveredAccountDetails")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/DiscoveredAccounts/{AccountID}"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDiscoveredAccountsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	filter *string
	search *string
	searchType *string
	offset *float32
	limit *float32
	authorization *string
	contentType *string
}

// search accounts using platformType, privileged, and/or accountEnabled values
func (r ApiGetDiscoveredAccountsRequest) Filter(filter string) ApiGetDiscoveredAccountsRequest {
	r.filter = &filter
	return r
}
// search is supported for username and address
func (r ApiGetDiscoveredAccountsRequest) Search(search string) ApiGetDiscoveredAccountsRequest {
	r.search = &search
	return r
}
// keyword is contained (contains, DEFAULT) or beginning (startswith)
func (r ApiGetDiscoveredAccountsRequest) SearchType(searchType string) ApiGetDiscoveredAccountsRequest {
	r.searchType = &searchType
	return r
}
// the offset of the first returned account in the list of results
func (r ApiGetDiscoveredAccountsRequest) Offset(offset float32) ApiGetDiscoveredAccountsRequest {
	r.offset = &offset
	return r
}
// the maximum number of accounts to return (maximum value allowed is 1000)
func (r ApiGetDiscoveredAccountsRequest) Limit(limit float32) ApiGetDiscoveredAccountsRequest {
	r.limit = &limit
	return r
}
// Session Authorization Token
func (r ApiGetDiscoveredAccountsRequest) Authorization(authorization string) ApiGetDiscoveredAccountsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetDiscoveredAccountsRequest) ContentType(contentType string) ApiGetDiscoveredAccountsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetDiscoveredAccountsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetDiscoveredAccountsExecute(r)
}

/*
GetDiscoveredAccounts Get Discovered Accounts

This method returns a list of all the discovered accounts from the Pending Accounts list. To run this web service, the user must be a member of the Vault admins group.
  	
**Note:** Discovered accounts that were onboarded either manually or automatically, according to predefined rules, won't be returned using this method.

For more information on available filters, please visit [Filter Parameters](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/11.6/en/Content/WebServices/Get-discovered-accounts.htm#filter-parameters) in the CyberArk API Documentation.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoveredAccountsRequest
*/
func (a *DefaultApiService) GetDiscoveredAccounts(ctx _context.Context) ApiGetDiscoveredAccountsRequest {
	return ApiGetDiscoveredAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetDiscoveredAccountsExecute(r ApiGetDiscoveredAccountsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDiscoveredAccounts")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/passwordvault/api/DiscoveredAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filter == nil {
		return nil, reportError("filter is required and must be specified")
	}
	if r.search == nil {
		return nil, reportError("search is required and must be specified")
	}
	if r.searchType == nil {
		return nil, reportError("searchType is required and must be specified")
	}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	localVarQueryParams.Add("searchType", parameterToString(*r.searchType, ""))
	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetJustinTimeAccessRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiGetJustinTimeAccessRequest) Authorization(authorization string) ApiGetJustinTimeAccessRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetJustinTimeAccessRequest) ContentType(contentType string) ApiGetJustinTimeAccessRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetJustinTimeAccessRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetJustinTimeAccessExecute(r)
}

/*
GetJustinTimeAccess Get Just in Time Access

This method requests and receives access to a target Windows machine with administrative rights. The domain user who runs this web service will be added to the local Administrators group of the target machine.

## Supported target machine environments

Just in Time access is supported on the following end user machine environments:

* Windows Server 2012/2012R2/2016
* Windows 8, Windows 10

## Configuration

Configure Just in Time access as described in [Configure Just in Time Access](https://docs.cyberark.com/Product-Doc/OnlineHelp/PAS/11.3/en/Content/PASIMP/adhoc_access_admin.htm).

## User permissions

Make sure that all users who want to request access to the target Windows machine must have the following permission in the Safe:

* List accounts

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiGetJustinTimeAccessRequest
*/
func (a *DefaultApiService) GetJustinTimeAccess(ctx _context.Context, accountID string) ApiGetJustinTimeAccessRequest {
	return ApiGetJustinTimeAccessRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetJustinTimeAccessExecute(r ApiGetJustinTimeAccessRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetJustinTimeAccess")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}/grantAdministrativeAccess"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPasswordValueRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
	body *string
}

func (r ApiGetPasswordValueRequest) Authorization(authorization string) ApiGetPasswordValueRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetPasswordValueRequest) ContentType(contentType string) ApiGetPasswordValueRequest {
	r.contentType = &contentType
	return r
}
// This method enables users to retrieve the password or SSH key of an existing account that is identified by its Account ID. It enables users to specify a reason and ticket ID, if required.  **Note:** The ability to retrieve credentials using this REST API is intended for human use only and is not recommended for applications or automated processes, where application-based authentication is required.  For application or automated processes use cases, refer to the [AAM Credential Providers Online Help](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-CP/Latest/en/Default.htm).
func (r ApiGetPasswordValueRequest) Body(body string) ApiGetPasswordValueRequest {
	r.body = &body
	return r
}

func (r ApiGetPasswordValueRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetPasswordValueExecute(r)
}

/*
GetPasswordValue Get Password Value

This method enables users to retrieve the password or SSH key of an existing account that is identified by its Account ID. It enables users to specify a reason and ticket ID, if required.

**Note:** The ability to retrieve credentials using this REST API is intended for human use only and is not recommended for applications or automated processes, where application-based authentication is required.

For application or automated processes use cases, refer to the [AAM Credential Providers Online Help](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-CP/Latest/en/Default.htm).

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiGetPasswordValueRequest
*/
func (a *DefaultApiService) GetPasswordValue(ctx _context.Context, accountID string) ApiGetPasswordValueRequest {
	return ApiGetPasswordValueRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetPasswordValueExecute(r ApiGetPasswordValueRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetPasswordValue")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Accounts/{AccountID}/Password/Retrieve"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSafeAccountGroupsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	safe string
}


func (r ApiGetSafeAccountGroupsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSafeAccountGroupsExecute(r)
}

/*
GetSafeAccountGroups Get Safe Account Groups

This method returns all the existing account groups in a specific Safe. The user performing this task must have the following permissions in the Safe:

* Add accounts
* Update account content
* Update account properties
* Create folders

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safe
 @return ApiGetSafeAccountGroupsRequest
*/
func (a *DefaultApiService) GetSafeAccountGroups(ctx _context.Context, safe string) ApiGetSafeAccountGroupsRequest {
	return ApiGetSafeAccountGroupsRequest{
		ApiService: a,
		ctx: ctx,
		safe: safe,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetSafeAccountGroupsExecute(r ApiGetSafeAccountGroupsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSafeAccountGroups")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Safes/{Safe}/AccountGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"Safe"+"}", _neturl.PathEscape(parameterToString(r.safe, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSafeDetailsRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	safe string
}

func (r ApiGetSafeDetailsRequest) Authorization(authorization string) ApiGetSafeDetailsRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetSafeDetailsRequest) ContentType(contentType string) ApiGetSafeDetailsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetSafeDetailsRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetSafeDetailsExecute(r)
}

/*
GetSafeDetails Get Safe Details

This method returns information about a specific Safe in the Vault.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safe
 @return ApiGetSafeDetailsRequest
*/
func (a *DefaultApiService) GetSafeDetails(ctx _context.Context, safe string) ApiGetSafeDetailsRequest {
	return ApiGetSafeDetailsRequest{
		ApiService: a,
		ctx: ctx,
		safe: safe,
	}
}

// Execute executes the request
//  @return Model200
func (a *DefaultApiService) GetSafeDetailsExecute(r ApiGetSafeDetailsRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSafeDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes/{Safe}"
	localVarPath = strings.Replace(localVarPath, "{"+"Safe"+"}", _neturl.PathEscape(parameterToString(r.safe, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSafeMembersRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	filter *string
	search *string
	offset *float32
	limit *float32
	sort *string
	authorization *string
	contentType *string
	safe string
}

// Filters are according to the REST standard. Search for Safe members using the following filters. Multiple filters can be applied using the AND operator. memberType, membershipExpired, includePreDefinedUsers
func (r ApiGetSafeMembersRequest) Filter(filter string) ApiGetSafeMembersRequest {
	r.filter = &filter
	return r
}
// Searches according to the Safe name. Search is performed according to the REST standard (search&#x3D;\&quot;search word\&quot;).
func (r ApiGetSafeMembersRequest) Search(search string) ApiGetSafeMembersRequest {
	r.search = &search
	return r
}
// Offset of the first member that is returned in the collection of results.
func (r ApiGetSafeMembersRequest) Offset(offset float32) ApiGetSafeMembersRequest {
	r.offset = &offset
	return r
}
// The maximum number of members that are returned. When used together with the offset parameter, this value determines the number of Safes to return, starting from the first Safe that is returned.
func (r ApiGetSafeMembersRequest) Limit(limit float32) ApiGetSafeMembersRequest {
	r.limit = &limit
	return r
}
// Sorts according to the memberName property in ascending order (default) or descending order to control the sort direction.
func (r ApiGetSafeMembersRequest) Sort(sort string) ApiGetSafeMembersRequest {
	r.sort = &sort
	return r
}
// Session Authorization Token
func (r ApiGetSafeMembersRequest) Authorization(authorization string) ApiGetSafeMembersRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetSafeMembersRequest) ContentType(contentType string) ApiGetSafeMembersRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetSafeMembersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.GetSafeMembersExecute(r)
}

/*
GetSafeMembers Get Safe Members

This method returns a list of the members of a Safe. To run this web service, the user must have **ViewSafeMembers** permissions in the Safe.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param safe
 @return ApiGetSafeMembersRequest
*/
func (a *DefaultApiService) GetSafeMembers(ctx _context.Context, safe string) ApiGetSafeMembersRequest {
	return ApiGetSafeMembersRequest{
		ApiService: a,
		ctx: ctx,
		safe: safe,
	}
}

// Execute executes the request
func (a *DefaultApiService) GetSafeMembersExecute(r ApiGetSafeMembersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSafeMembers")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Safes/{Safe}/Members"
	localVarPath = strings.Replace(localVarPath, "{"+"Safe"+"}", _neturl.PathEscape(parameterToString(r.safe, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.filter == nil {
		return nil, reportError("filter is required and must be specified")
	}
	if r.search == nil {
		return nil, reportError("search is required and must be specified")
	}
	if r.offset == nil {
		return nil, reportError("offset is required and must be specified")
	}
	if r.limit == nil {
		return nil, reportError("limit is required and must be specified")
	}
	if r.sort == nil {
		return nil, reportError("sort is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	localVarQueryParams.Add("search", parameterToString(*r.search, ""))
	localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSafebyPlatformIDRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	platformName string
}

func (r ApiGetSafebyPlatformIDRequest) Authorization(authorization string) ApiGetSafebyPlatformIDRequest {
	r.authorization = &authorization
	return r
}
func (r ApiGetSafebyPlatformIDRequest) ContentType(contentType string) ApiGetSafebyPlatformIDRequest {
	r.contentType = &contentType
	return r
}

func (r ApiGetSafebyPlatformIDRequest) Execute() (Model200, *_nethttp.Response, error) {
	return r.ApiService.GetSafebyPlatformIDExecute(r)
}

/*
GetSafebyPlatformID Get Safe by Platform ID

This method returns all the safes according to the platform ID.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param platformName
 @return ApiGetSafebyPlatformIDRequest
*/
func (a *DefaultApiService) GetSafebyPlatformID(ctx _context.Context, platformName string) ApiGetSafebyPlatformIDRequest {
	return ApiGetSafebyPlatformIDRequest{
		ApiService: a,
		ctx: ctx,
		platformName: platformName,
	}
}

// Execute executes the request
//  @return Model200
func (a *DefaultApiService) GetSafebyPlatformIDExecute(r ApiGetSafebyPlatformIDRequest) (Model200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Model200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSafebyPlatformID")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/api/Platforms/{PlatformName}/Safes"
	localVarPath = strings.Replace(localVarPath, "{"+"PlatformName"+"}", _neturl.PathEscape(parameterToString(r.platformName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReconcilePasswordRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiReconcilePasswordRequest) Authorization(authorization string) ApiReconcilePasswordRequest {
	r.authorization = &authorization
	return r
}
func (r ApiReconcilePasswordRequest) ContentType(contentType string) ApiReconcilePasswordRequest {
	r.contentType = &contentType
	return r
}

func (r ApiReconcilePasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReconcilePasswordExecute(r)
}

/*
ReconcilePassword Reconcile Password

This method marks an account for automatic reconciliation by the CPM.

The user who runs this web service requires the following permission in the Safe where the privileged account is stored:

* Initiate CPM password management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiReconcilePasswordRequest
*/
func (a *DefaultApiService) ReconcilePassword(ctx _context.Context, accountID string) ApiReconcilePasswordRequest {
	return ApiReconcilePasswordRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReconcilePasswordExecute(r ApiReconcilePasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReconcilePassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Accounts/{AccountID}/Reconcile"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVerifyPasswordRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	authorization *string
	contentType *string
	accountID string
}

func (r ApiVerifyPasswordRequest) Authorization(authorization string) ApiVerifyPasswordRequest {
	r.authorization = &authorization
	return r
}
func (r ApiVerifyPasswordRequest) ContentType(contentType string) ApiVerifyPasswordRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVerifyPasswordRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VerifyPasswordExecute(r)
}

/*
VerifyPassword Verify Password

This method marks an account for verification by the CPM, and can be used in versions from v9.10.

The user who runs this web service requires the following permission in the Safe where the privileged account is stored:

* Initiate CPM password management operations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountID
 @return ApiVerifyPasswordRequest
*/
func (a *DefaultApiService) VerifyPassword(ctx _context.Context, accountID string) ApiVerifyPasswordRequest {
	return ApiVerifyPasswordRequest{
		ApiService: a,
		ctx: ctx,
		accountID: accountID,
	}
}

// Execute executes the request
func (a *DefaultApiService) VerifyPasswordExecute(r ApiVerifyPasswordRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VerifyPassword")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/PasswordVault/API/Accounts/{AccountID}/Verify"
	localVarPath = strings.Replace(localVarPath, "{"+"AccountID"+"}", _neturl.PathEscape(parameterToString(r.accountID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
